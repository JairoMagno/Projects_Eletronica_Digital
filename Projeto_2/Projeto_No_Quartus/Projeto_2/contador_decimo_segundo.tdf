TITLE "contador décimo de segundo";

SUBDESIGN contador_decimo_segundo(
	clock  				: INPUT;					--clock vindo do seletor_clock_contador
	enable 				: INPUT;					--ativar contador
	clear  				: INPUT;					--zerar contador
	q[3..0] 				: OUTPUT;				--vetor de 4 bits
	clk_und_seg 		: OUTPUT;				--clock que vai para o próximo contador (contador_segundo)
)

VARIABLE 

	contador[3..0] 	: DFF;					--contador de 4 bits (4 flip-flops D)
	aux 				 	: DFF;					--variável auxiliar  (1 flip-flop D)

BEGIN

	--entrada
	contador[].clk 	= clock;					--atribuindo o clock vindo do seletor_clock_contador
	aux.clk 				= clock;					--atribuindo o clock vindo do seletor_clock_contador
	contador[].clrn	= NOT clear;			--barrando todos os clear 
	
	--saída
	q[]					= contador[].q;		--mostrar o valor da contagem que está na sáida o flip flop
	clk_und_seg 		= aux.q;					--mostrar o valor da variável aux

	IF enable THEN 								--verificar se o contador já chegou na sua representação máxima
		IF contador[].q == 9 THEN				--atribiu zero na entrada do contador
			contador[].d = 0;
			aux.d 		 = VCC;					--atribui o valor em VCC representando que o contador chegou a seu valor máximo
			
		ELSE 
			contador[].d = contador[].q + 1; --enquanto não chegar em 9 a saída será incrementada
			aux.d 		 = GND;
		END IF; 
	
	ELSE 
		contador[].d = contador[].q;			--caso o enable não seja ativado atribui a saída do contador na entrada	
	END IF;
	
END;